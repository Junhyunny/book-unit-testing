
## 1. 단위 테스트의 목표

테스트에 드는 노력을 가능한 줄이고 그에 따르는 이득을 최대화해야 한다. 
두 가지를 모두 달성하기는 쉽지 않지만, 균형을 달성한 프로젝트는 무난히 성장하고, 유지 보수가 많이 필요하지 않다. 
끊임없이 변화하는 고객의 요구에 신속하게 대응할 수 있다. 

이 책에서 다루는 내용은 다음과 같다.

* 어떤 단위 테스트 기술이 좋은지 구별하는 방법
* 비용 편익 분석(cost-benefit analysis) 방법을 배우고 특정 상황에서 적절한 테스트 기술을 적용하는 방법
* 공통적인 안티 패턴을 피하는 방법

### 1.1. 단위 테스트 현황

기업용 어플리케이션 개발 프로젝트는 거의 모두 단위 테스트가 적용되어 있다. 
많은 프로젝트에는 자동화된 테스트가 있고, 많은 테스트들이 실행된다. 
테스트를 통해 원하는 결과를 얻지 못하는 경우가 많다. 

새로운 기능을 구현하려면 시간이 많이 들고, 이미 구현된 기능에는 새로운 버그가 지속적으로 나타난다. 
도움이 될 것이라 생각한 단위 테스트는 이런 상황에 전혀 도움이 되지 않고 상황을 악화시킬 수도 있다. 
이는 제대로 작동하지 않는 단위 테스트의 결과다. 
좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업 중인 프로젝트의 성패를 가르는 문제다. 

### 1.2. 단위 테스트의 목표

코드베이스에 대헤 단위 테스트를 작성하는 행동은 일반적으로 더 나은 설계로 이어진다. 
하지만 단위 테스트의 주 목표는 아니다. 
더 나은 설계는 단지 좋은 부수 효과일 뿐이다. 

##### 단위 테스트와 코드 설계의 관계

* 좋은 부정 지표로서 단위 테스트
    * 비교적 높은 정확도로 저품질 코드를 가려낸다. 
    * 코드를 단위 테스트하기 어렵다면 코드 개선이 반드시 필요하다는 의미이다. 
    * 강결합(tight coupling)에서 저품질이 나타나는데, 제품 코드가 충분히 분리되지 않아서 따로 테스트하기 어려움을 뜻한다. 
* 나쁜 긍정 지표로서 단위 테스트
    * 쉬운 테스트가 가능하더라도 코드베이스의 품질이 좋다는 의미가 아니다.

> 단위 테스트의 목표는 무엇인가?<br/>
> 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것이다.

프로젝트는 처음엔 쉽게 성장할 수 있다. 
하지만 시간이 지나면서 계속 성장하기는 어렵다. 
프로젝트 초창기에 성장 속도가 빠른 이유는 다음과 같다. 

* 잘못된 아키텍처 결정
* 걱정할 만한 코드

테스트가 없는 프로젝트는 초반엔 작업 소요 시간이 짤지만, 진행할수록 작업 소요 시간이 기하 급수적으로 길어진다. 
테스트가 포함된 프로젝트는 초반엔 작업 소요 시간이 어느 정도 걸리지만, 진행할수록 눈에 띄게 길어지진 않는다. 

##### 소프트웨어 엔트로피(Software Entropy)

* 엔트로피(무질서도)는 품질을 떨어뜨리는 코드 형태로 나타난다. 
* 코드베이스에서 무언가를 변경할 때마다 엔트로피는 증가한다.
* 지속적인 정리와 리팩터링 같은 적절한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해진다. 
* 하나의 버그는 더 많은 버그를 양산한다.
* 소프트웨어의 한 부분을 수정하면 다른 부분들이 고장한다.

테스트는 안정막 역할을 한다. 
회귀(regression)에 대한 보험을 제공하는 도구이다. 
(회귀는 특정 사건 후에 기능이 의도한 대로 작동하지 않는 경우이다. 버그와 동의어로 사용할 수 있다.)
새로운 기능을 도입하거나 새로운 요구 사항에 더 잘 맞게 리팩터링한 후에도 기존 기능이 잘 동작하는지 확인하는 데 도움을 준다. 

단점은 초반에 노력이 필요하다는 것이다. 
그러나 프로젝트 후반에도 잘 성장할 수 있도록 하므로 장기적으로 보면 그 비용을 메울 수 있다. 
코드베이스를 지속적으로 검증하는 테스트 없이는 소프트웨어 개발이 쉽게 확장되지 않는다. 
핵심은 프로젝트의 지속성과 확장성이다. 

#### 1.2.1. 좋은 테스트와 좋지 않은 테스트를 가르는 요인

단위 테스트가 프로젝트 성장에 도움이 되는 것은 맞지만, 잘못된 테스트는 여전히 프로젝트 성장을 방해한다. 
잘못된 테스트도 초반에 코드가 나빠지는 것을 늦출 수 있다. 
거시적 관점에서는 큰 차이가 없다. 
프로젝트 개발 속도가 현저히 떨어지는 침체 단계에 진입하는 데 시간이 더 걸릴 수 있지만, 피할 수 없다. 

일부 테스트는 아주 중요하고 소프트웨어 품질에 매우 많은 기여를 한다. 
그 밖에 다른 테스트는 그렇지 않다. 

* 잘못된 경고를 발생한다.
* 회구 오류를 알아내는 데 도움이 되지 않는다.
* 유지 보수가 어렵고 느리다.
* 프로젝트에 도움이 되는지 여부를 명확하게 파악하지 않고 단위 테스트를 작성하는 데만 빠져들기 쉽다.

테스트의 가치와 유지 비용을 모두 고려한다. 
다음과 같은 활동을 통해 테스트의 품질을 유지해라.

* 기반 코드를 리팩토링할 때 테스트도 함께 리팩토링한다.
* 각 코드 변경 시 테스트를 실행한다.
* 테스트가 잘못된 경고를 발생시킬 경우 처리한다.
* 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자해라.

지속 가능한 프로젝트 성장을 위해서는 고품질 테스트에만 집중한다. 
좋은 단위 테스트와 나쁜 단위 테스트를 구별하는 방법을 익히는 것이 중요하다.

##### 제품 코드와 테스트 코드

* 테스트 코드를 제품 코드에 덤으로 추가된 것이라 간주하면 안 된다. 
* 테스트가 많으면 많을수록 좋다고 오해하지 마라.
* 코드는 자산이 아니라 책임이다. 
* 코드가 많을수록 소프트웨어 내의 잠재적인 버그에 노출되는 표면적이 더 넓어지고 프로젝트 유지 비용이 증가한다.
* 테스트 코드도 어플리케이션의 정확성을 보장하는 것을 목표로 하는 코드베이스의 일부이다.
* 다른 코드와 마찬가지로 버그에 취약하고 유지 보수가 필요하다.

### 1.3. 테스트 스위트 품질 측정을 위한 커버리지 지표

커버리지 지표는 테스트 스위트가 소스 코드를 얼마나 실행했는지를 백분율로 나타내는 것이다. 

특정 커버리지 숫자를 목표로 하는 것이 해롭다. 
테스트 스위트 품질을 결정하는데 커버리지 지표에 의존하면 안된다. 

커버리지 지표는 각기 다른 유형이 있으며 일반적으로 커버리지는 숫자가 높을수록 좋지만, 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다. 
커버리지 지표는 괜찮은 부정 지표지만, 좋지 않은 긍정 지표이다. 

* 코드 커버리지가 너무 적을 때는 테스트가 충분히자 않다는 좋은 증거이다.
* 코드 커버리지가 100%라고 해서 반드시 양질의 테스트 스위트라고 보장하지 않는다. 

#### 1.3.1. 코드 커버리지 지표에 대한 이해

가장 많이 사용되는 커버리지 지표이다. 
테스트 커버리지로도 알려져 있다. 
하나 이상의 테스트로 실행된 코드 라인 수와 제품 코드베이스의 전체 라인 수의 비율을 나타낸다. 

* 코드 커버리지(테스트 커버리지) = 실행 코드 라인 수 / 전체 라인 수

다음 예시 코드를 코드 커버리지를 확인해보겠습니다.

* isStringLong 메소드에서 실행되는 코드 영역은 2줄 입니다.
* 3줄 중에 2줄이 실행되었으므로 코드 커버리지 지표는 66% 입니다.
    * 2/3 = 0.666666...

```java
package blog.in.action.lifecycle;

import org.junit.jupiter.api.Test;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

public class ExampleTests {

    @Test
    void abc_is_short() {
        Target sut = new Target();


        boolean result = sut.isStringLong("abc");


        assertThat(result, equalTo(false));
    }
}

class Target {
    boolean isStringLong(String input) {
        if (input.length() > 5) {
            return true;
        }
        return false;
    }
}
```

##### 조작된 코드 커버리지

코드 커버리지는 쉽게 조작할 수 있습니다. 
다음과 같은 예시를 살펴보겠습니다.

* isStringLong 메소드에서 실행되는 코드 영역은 1줄 입니다.
* 1줄 중에 1줄이 실행되었으므로 코드 커버리지 지표는 100% 입니다.

```java
package blog.in.action.lifecycle;

import org.junit.jupiter.api.Test;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

public class ExampleTests {

    @Test
    void abc_is_short() {
        Target sut = new Target();


        boolean result = sut.isStringLong("abc");


        assertThat(result, equalTo(false));
    }
}

class Target {
    boolean isStringLong(String input) {
        return input.length() > 5;
    }
}
```

#### 1.3.2. 분기 커버리지 지표에 대한 이해

코드 커버리지의 단점을 극복하는 데 도움이 된다. 
코드 커버리지보다 더 정확한 결과를 제공한다. 
분기 커버리지 지표는 원시 코드 라인 수를 사용하는 대신 `if`, `switch` 문과 같은 제어 구조에 중점을 둔다. 

* 분기 커버리지 = 통과 분기 / 전체 분기 수

다음 예시 코드를 분기 커버리지를 확인해보겠습니다.

* isStringLong 메소드에서 2개의 분기가 존재합니다.
    * 입력된 문자열이 5보다 큰 경우
    * 입력된 문자열이 5보다 작은 경우
* 2개의 분기 중에 1개의 분기만 실행했으므로 분기 커버리지는 50% 입니다.

```java
package blog.in.action.lifecycle;

import org.junit.jupiter.api.Test;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

public class ExampleTests {

    @Test
    void abc_is_short() {
        Target sut = new Target();


        boolean result = sut.isStringLong("abc");


        assertThat(result, equalTo(false));
    }
}

class Target {
    boolean isStringLong(String input) {
        return input.length() > 5;
    }
}
```

#### 1.3.3. 커버러지 지표에 문제점

테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 의존할 수 없는 이유는 다음과 같다.

* 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
* 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

다음과 같은 예시를 살펴보겠습니다.

* 위 예제와 마찬가지로 코드 커버리지는 100%, 분기 커버리지 50% 이지만, `wasLastStringLong` 값을 검증하지 않았습니다.
* 커버리지 지표는 코드가 실행된 것만 보장할 뿐 실제 기반 코드를 테스트했다고 보장할 수 없습니다. 

```java
package blog.in.action.lifecycle;

import org.junit.jupiter.api.Test;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

public class ExampleTests {

    @Test
    void abc_is_short() {
        Target sut = new Target();


        boolean result = sut.isStringLong("abc");


        assertThat(result, equalTo(false));
    }
}

class Target {

    static boolean wasLastStringLong;

    boolean isStringLong(String input) {
        boolean result =  input.length() > 5;
        wasLastStringLong = result;
        return result;
    }
}
```

#### 1.3.4. 특정 커버리지 숫자를 목표로 하기

특정 커버리지 숫자를 목표로 삼기 시작하면 위험 영역으로 이어진다. 
커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안 된다. 
사람들이 중요한 것을 테스트하는 데 집중하는 대신 인공적인 목표를 달성하기 위한 방법을 찾기 시작한다. 

커버리지 지표는 좋은 부정 지표이다. 
커버리지 숫자가 낮으면 문제 징후라 할 수 있다. 

커버리지 지표는 나쁜 긍정 지표이다. 
커버리지 지표가 높다고 좋은 품질의 코드 기반을 만드는 것은 아니다.

### 1.4. 무엇이 성공적인 테스트 스위트를 만드는가?

테스트 스위트가 얼마나 좋은지 개인 판단에 맡겨야 한다. 
성공적인 테스트 스위트는 다음과 같은 특성을 갖고 있다.

* 개발 주기에 통합돼 있다.
* 코드베이스에서 가장 중요한 부분만 대상으로 한다.
* 최소한의 유지비로 최대의 가치를 끌어낸다.

#### 1.4.1. 개발 주기에 통합되어 있다.

자동화 된 테스트를 할 수 있는 방법은 끊임없이 하는 것이다. 
모든 테스트는 개발 주기에 통합되어 있어야 한다. 
코드 변경이 아주 작은 것이라도 반드시 테스트는 실행해야 한다.

#### 1.4.2. 코드베이스에서 가장 중요한 부분만 대상으로 한다.

테스트가 주는 가치는 테스트 구조뿐만 아니라 검증하는 코드에도 있다. 
시스템의 가장 중요한 부분에 단위 테스트 노력을 기울인다. 
다른 부분은 간략하고 또는 간접적으로 검증하는 것이 좋다. 
대부분의 어플리케이션에서 가장 중요한 부분은 비즈니스 로직(도메인 모델)이 있는 부분이다. 
비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낸다. 

그 외에 다른 부분은 다음과 같다.

* 인프라 코드
* 데이터베이스나 서드 파티 시스템과 같은 외부 서비스 및 종속성
* 모든 것을 하나로 묶는 코드

도메인 모델을 초점으로 테스트를 작성해야하기 때문에 도메인 모델을 코드베이스 중 중요하지 않은 부분과 분리해야 한다. 
도메인 모델을 다른 어플리케이션 문제와 분리해야 단위 테스트에 대한 노력을 도메인 모델에만 집중할 수 있다. 

#### 1.4.3. 최소 유지비로 최대 가치를 끌어낸다.

테스트를 빌드 시스템에 통합하는 것과 도메인 모델에 높은 테스트 커버리지를 유지하는 것만으로 충분하지 않다. 
가치가 유지 비용을 상회하는 테스트만 스위트에 유지하는 것이 중요하다. 

* 가치 있는 테스트 식별하기
* 가치 있는 테스트 작성하기

가치가 높은 테스트를 식별하려면 기준 틀이 필요하다. 
가치 있는 테스트를 작성하려면 코드 설계 기술을 잘 알아야 한다. 
단위 테스트와 기반 코드는 서로 얽혀 있으므로 코드베이스에 노력을 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없다.

### 1.5. 이 책을 통해 배우는 것

이 책은 테스트 스위트 내의 모든 테스트를 분석하는 데 사용할 수 있는 기준 틀을 설명한다. 
기준 틀을 기초로 새로운 관점에서 많은 테스트를 바라보며, 어떤 것이 프로젝트에 기여하고 어떤 것을 리팩토링해야 하거나 완전히 제거해야 하는지 알 수 있다. 

기준 틀 이 외에도 다음과 같은 내용을 다룬다. 

* 제품 코드와 관련된 테스트 스위트를 리팩토링하는 방법
* 단위 테스트를 다양한 스타일로 적용하는 방법
* 통합 테스트로 시스템 전체 동작을 검증하는 방법
* 단위 테스트 안티 패턴을 식별하고 예방하는 방법
