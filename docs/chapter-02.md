
## 2. 단위 테스트란 무엇인가

단위 테스트의 정의에 따라 접근하는 방법이 두 가지로 나뉘었다. 

* 고전파(classical school)
    * 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식
    * 디트로이트 스타일
    * 켄트 벡의 "테스트 주도 개발"이 가장 고전적인 책
* 런던파(london school)
    * 런던의 프로그래밍 커뮤티니에서 유래
    * 목 추종자(mockist)
    * 스티브 프리먼(Steve Freeman), 냇 프라이스(Nat Pryce)가 유명

### 2.1. 단위 테스트 정의

중요하지 않은 것을 제외한 단위 테스트 정의는 다음과 같다.

* 작은 코드 조각을 검증
* 빠르게 수행
* 격리된 방식으로 처리하는 자동화된 테스트

작은 코드 조각을 검증하는 것과 빠르게 수행하는 것은 논란의 여지가 없다. 
격리 문제에 대한 해석 차이에서 고전파와 런던파로 나뉜다. 

#### 2.1.1. 격리 문제에 대한 런던파의 접근

테스트 대상 시스템을 협력자에게서 격리하는 방식이다. 
하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역(test double)으로 대체하는 방식이다. 
테스트 대역을 사용하면 의존성이 포함된 테스트 대상 시스템을 검증하는 단위 테스트는 의존성과 무관하게 동작한다. 

다음과 같은 장점이 있다.

* 테스트가 실패하면 코드 베이스의 어느 부분이 고장 났는지 확실히 알 수 있다. 
* 테스트 대역은 에러가 발생하지 않으니 분명 테스트 대상 시스텀이 고장이 난 것이다. 
* 객체 그래프(같은 문제를 해결하는 클래스 통신망)를 분할할 수 있다. 

의존성을 가진 코드 베이스를 테스트하는 것은 테스트 대역 없이는 어렵다. 
객체 그래프를 다시 만드는 것이 유일한 방법이지만, 클래스가 너무 많은 경우 어려운 작업이 된다. 
테스트 대역을 사용하면 객체 그래프를 다시 만들지 않아도 된다. 

단위 테스트를 격리하면 프로젝트 전반적으로 한 번에 한 클래스만 테스트하라는 지침을 도입할 수 있다. 
테스트 스위트가 간단한 구조로 정해진다. 

##### 고전 스타일 테스트 코드 예시

* 의존성과 테스트 대상 시스템을 준비
    * 테스트 대상 시스템(SUT, System Under Test) - Customer 클래스
    * 협력자 - Store 클래스
* `purchase` 메소드 호출이 검증하고자 하는 동작을 수행
* 검증(assert) 구문들이 검증 단계
* 동작 결과가 예상 결과로 이어지는지 확인

```java
package org.example;

import org.example.domain.Customer;
import org.example.domain.Product;
import org.example.domain.Store;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class ClassicTests {

    @Test
    void purchase_succeeds_when_enough_inventory() {

        Store store = new Store();
        store.addInventory(Product.Shampoo, 10);
        Customer customer = new Customer();


        boolean success = customer.purchase(store, Product.Shampoo, 5);


        assertTrue(success);
        assertEquals(5, store.getInventory(Product.Shampoo));
    }

    @Test
    void purchase_fails_when_not_enough_inventory() {

        Store store = new Store();
        store.addInventory(Product.Shampoo, 10);
        Customer customer = new Customer();


        boolean success = customer.purchase(store, Product.Shampoo, 15);


        assertFalse(success);
        assertEquals(10, store.getInventory(Product.Shampoo));
    }
}
```

##### 고전 스타일 예시 코드 고찰

고전 스타일 테스트는 협력자를 대체하지 않고 운영용 인스턴스를 사용한다. 
고전적인 방식의 자연스러운 결과로 `Customer`, `Store` 클래스 모두를 검증한다. 
`Customer` 객체가 올바르게 동작하더라도 `Store` 내부에 버그가 있으면 단위 테스트가 실패한다. 
두 클래스는 서로 격리되어 있지 않다. 

##### 런던 스타일 테스트 코드 예시

* 실제 인스턴스를 사용하지 않고, `Mockito`를 사용한 스텁 객체 생성
* 인터페이스를 선언하여 사용
* 스텁 객체가 반환하는 값을 미리 지정
* 객체의 상태를 검증하지 않고, 객체의 동작을 검증
    * 호출 메소드뿐만 아니라 호출 횟수까지 검증

```java
package org.example;

import org.example.domain.Customer;
import org.example.domain.IStore;
import org.example.domain.Product;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.*;

public class LondonTests {

    @Test
    void purchase_succeeds_when_enough_inventory() {

        IStore store = Mockito.mock(IStore.class);
        when(store.hasEnoughInventory(Product.Shampoo, 5)).thenReturn(true);


        Customer customer = new Customer();
        boolean success = customer.purchase(store, Product.Shampoo, 5);


        assertTrue(success);
        verify(store, times(1)).removeInventory(Product.Shampoo, 5);
    }

    @Test
    void purchase_fails_when_not_enough_inventory() {

        IStore store = Mockito.mock(IStore.class);
        when(store.hasEnoughInventory(Product.Shampoo, 15)).thenReturn(false);


        Customer customer = new Customer();
        boolean success = customer.purchase(store, Product.Shampoo, 15);


        assertFalse(success);
        verify(store, times(0)).removeInventory(Product.Shampoo, 5);
    }
}
```

##### 런던 스타일 예시 코드 고찰

런던 스타일은 협업 객체가 내부에서 동작하는 모습을 실제로 알아야 한다. 
즉, 테스트 대상 클래스의 실제 구현체 모습을 알고 있어야 한다. 
협력 객체를 인터페이스로 정의하면 테스트 대상 객체 내부에서 어떤 기능을 노출하지 아웃 라인이 보인다.

#### 2.1.2. 격리 문제에 대한 고전파의 접근

런던 스타일은 테스트 대역으로 테스트 대상 코드 조각을 분리해서 격리 요구 사항에 다가간다. 
테스트 격리에 대한 요구사항은 테스트 조각 크기에도 영향을 미친다. 

> 작은 코드 조각은 얼마나 작아야 하는가? 

모든 클래스를 격리해야 한다면 코드 조각은 단일 클래스이거나 메소드여야 한다. 
하지만, 격리 수준에 따라 동시에 여러 개의 클래스를 테스트할 수 있다. 
일반적으로 한 번에 한 클래스로 테스트하는 지침을 따르려고 노력해야 한다. 

고전적인 방법으로 격리 특성을 해석할 수 있다. 
코드를 격리하는 것이 아니라, 단위 테스트를 격리해서 실행해야 한다고 이야기한다. 
각 테스트들을 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 테스트 해도 괜찮다는 의미이다. 

테스트가 서로 소통하면 실행 컨텍스트에 영향을 줄 수 있는 경우가 있다. 

* 데이터베이스
* 파일 시스템
* 기타 프로세스 외부 의존성

##### 공유 의존성, 비공개 의존성, 프로세스 외부 의존성

* 공유 의존성
    * 테스트 간에 공유되고 서로 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
    * 예로 들면, 정적 가변 필드나 데이터베이스
* 비공개 의존성
    * 공유하지 않는 의존성
* 프로세스 외부 의존성
    * 어플리케이션 실행 프로세스 외부에서 실행되는 의존성
    * 메모리에 없는 데이터에 대한 프록시(proxy)
    * 프로세스 외부 의존성은 대부분 공유 의존성에 해당
    * 예를 들면 데이터베이스
    * 예외로 테스트 실행 전에 도커 컨테이너로 데이터베이스를 시작하면 테스트가 동일한 인스턴스를 사용하지 않으므로 외부이면서 공유하지 않는 의존성

격리 문제에 대한 해석에는 목과 기타 테스트 대역을 적당히 쓰라는 견해가 있다. 
테스트 대역을 사용할 수 있지만, 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용한다. 
공유 의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다. 

예를 들어, 싱글톤 패턴을 예로 들면 다음과 같다.

* 테스트마다 객체를 새로 만들면 싱글톤 객체도 공유 의존성이 아니다. 
* 제품 코드에선 단 하나만 있지만, 테스트는 이 패턴을 따르지 않고 재사용하지 않으므로 비공개 의존성이다. 

##### 공유 의존성과 휘발성 의존성

휘발성 의존성은 다음 속성 중 하나를 나타내는 의존성이다.

* 개발자 머신에 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구한다.
* 데이터베이스와 API 서비스가 좋은 예이다. 
* 추가 설정이 필요하며 시스템에 기본으로 설치돼 있지 않다.
* 비결정적 동작을 포함한다.
    * 난수 생성기 또는 현재 날짜와 시간을 반환하는 클래스
    * 각 호출에 대해 다른 결과를 제공하기 때문에 비결정적이라 한다.

공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이는 데 있다. 
공유 의존성은 거의 항상 실행 프로세스 외부에 있는 데 반해, 비공개 의존성은 보통 경계를 넘지 않는다. 
데이터베이스나 파일 시스템 등의 공유 의존성에 대한 호출은 비공개 의존성에 대한 호출보다 오래 걸린다. 
공유 의존성을 포함하는 테스트는 단위 테스트가 아닌 통합 테스트 영역이다. 

### 2.2. 단위 테스트의 런던파와 고전파

* 런던파는 테스트 대상 시스템에서 협력자를 격리
* 고전파는 단위 테스트끼리 격리

종합하면 세 가지 주요 주제에 대해 의견 차이가 있다.

* 격리 요구사항
* 테스트 대상 코드 조각의 구성 요소
* 의존성 처리

| | 격리 추제 | 단위의 크기 | 테스트 대역 사용 대상 |
|:---:|:---:|:---:|:---:|
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 | 
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 | 

#### 2.2.1. 고전파와 런턴파가 의존성을 다루는 방법

런턴파는 테스트에서 일부 의존성을 그대로 사용할 수 있도록 한다. 
절대 변하지 않는 객체, 불변 객체는 교체하지 않는다. 

* 고전파의 의존성 교체 대상
    * 공유 의존성
* 런던파의 의존성 교체 대상 - 협력자
    * 공유 의존성
    * 비공개 의존성 중에서 변경 가능한 의존성

모든 프로세스 외부 의존성이 공유 의존성의 범주에 속하진 않는다. 

* 공유 의존성은 거의 항상 프로세스 외부에 있다.
* 하지만, 프로세스 외부 의존성의 대부분이 공유 의존성이란 말은 아니다.
    * 예를 들어 읽기 전용으로 사용한 프로세스 외부 의존성
    * 모든 제품에 대한 카탈로그를 반환하는 API가 있는데, 카탈로그를 변경할 수 있는 기능을 노출하지 않으면 공유 의존성이 아니다.
* 프로세스 외부 의존성을 공유하려면 단위 테스트가 서로 통신할 수 있는 수단이 필요하다.
* 프로세스 외부 불변 의존성 같은 경우에는 테스트 내부의 어떤 것도 수정할 수 없기 때문에 실행 컨텍스트에 영향을 줄 수 없다.

공유 의존성이 아니라고 해서 테스트 대역을 사용하지 않는것은 아니다. 
외부 의존성이니만큼 속도 문제를 일으킬 수 있으므로 테스트 속도를 고려해서 테스트 대역을 사용하는 것이 좋다. 

### 2.3. 고전파와 런던파의 비교

고전파와 런던파 간의 주요 차이는 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다. 
작가는 고전파를 선호한다. 
고품질 테스트를 만들고 궁극적 목표인 프로젝트의 지속 가능한 성장을 달성하는데 적합하다. 
런던파처럼 목을 사용하는 테스트는 고전적인 테스트보다 불안정한 경향이 있다. 

런던파의 주요 장점은 다음과 같다. 

* 입자성이 좋다. 
    * 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
* 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다.
    * 모든 협력자는 테스트 대역으로 대체되기 때문에 테스트 작성 시 걱정할 필요가 없다.
* 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다.
    * 클래스의 협력자가 없으면 테스트 대상 클래스 외에 다른 것을 의심할 여지가 없다. 
    * 테스트 대상 시스템이 값 객체를 사용하는 상황이 있을 수 있으며, 이 값 객체의 변경으로 인해 테스트가 실패하게 된다.
    * 테스트 내 다른 의존성을 모두 제거했기 때문에 이러한 경우는 흔하지 않다. 

#### 2.3.1. 한 번에 한 클래스만 테스트하기

좋은 입자성은 단위 테스트에서 단위를 구성하는 것과 관련이 있다. 
런던파는 클래스를 단위로 간주한다. 
객체지향 프로그래밍에서 보통 클래스는 모든 코드 베이스의 기초에 위치한 원자 빌딩 블록으로 간주한다. 
자연스럽게 클래스를 테스트에서 검증할 원자 단위로도 취급한다. 

테스트는 코드의 단위를 검증해서는 안 된다. 
동작의 단위, 즉 문제 영역에 의미가 있는 것, 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다. 
동작 단위를 구현하는 데 클래스가 얼마나 필요한지는 상관없다. 

좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않는다. 
테스트가 단일 동작 단위를 검증하는 한 좋은 테스트다. 
이보다 더 작아지면 테스트가 무엇을 검증하는지 정확히 이해하기 어려워지기 때문에 테스트의 가치를 훼손한다. 

#### 2.3.2. 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다. 
테스트 대상 클래스에 의존성이 있고, 이 의존성에 다시 각각의 의존성이 있다. 
여러 계층에 걸쳐서 계속되는 식으로 의존성 그래프가 복잡하더라도 목을 사용하면 쉽게 테스트가 가능하다. 

테스트 대역을 사용하면 의존성 그래프를 다시 생성하지 않아도 된다. 
테스트 준비 작업이 크게 줄어든다. 

하지만, 클래스 그래프가 커지는 상황 자체를 막아야 한다. 
대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과이다. 
목은 이런 문제를 감추기만 한다. 

#### 2.3.3. 버그 위치 정확히 찾아내기

런던 스타일 테스트는 시스템에 버그가 생기면, 보통 SUT에 버그가 포함된 테스트만 실패한다. 
그렇기 때문에 빠르게 버그 위치를 파악하는 것이 가능하다. 

클래식 스타일은 실 구현체를 사용하기 때문에 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기한다. 
문제의 원인을 찾기 어려워진다. 
클래식 스타일은 테스트를 정기적으로 실행하여 버그의 원인을 알아낼 수 있다. 
마지막으로 한 수정이 무엇인지 알기 때문에 버그의 원인을 찾기 쉽다. 
실패한 테스트를 모두 볼 필요가 없이, 하나를 고치면 다른 것들도 자동으로 고쳐진다. 

클래식 스타일은 버그가 테스트 하나뿐만 아니라 전역에 퍼진 테스트를 실패시키기 때문에 해당 코드 조각의 영향도를 파악할 수 있다. 

#### 2.3.4. 고전파와 런던파 사이의 다른 차이점

* 테스트 주도 개발을 통한 시스템 설계 방식
* 과도한 명세 문제 (over-specification)

런던 스타일의 단위 테스트는 하향식 TDD이다.(outside-inside)
전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다. 
테스트 더블을 사용해 예상 결과를 달성하고자 시스템이 통신해야 하는 협력자를 지정한다. 
그 다음 모든 클래스를 구현할 때까지 클래스 그래프를 다져나간다. 
목은 한 번에 한 클래스에 집중할 수 있기 때문에 이런 설계 프로세스를 가능하게 한다. 

고전파는 실제 객체를 다루기 때문에 런던파와 다르다.(inside-outside) 
도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 위에 둔다. 

런던 스타일은 고전 스타일보다 테스트가 더 SUT의 구현 세부 사항에 결합된다. 
목을 전반적으로 아무 데나 쓰는 것에 대한 주의가 필요하다. 

### 2.4. 두 분파의 통합 테스트

런던 스타일은 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다. 
고전 스타일로 작성된 대부분의 테스트는 런던 지지자들 입장에선 통합 테스트이다. 

그러면 고전 스타일의 통합 테스트는 어떤지 살펴보자. 
고전 스타일의 통합 테스트는 다음과 같은 기준 중 하나를 충족하지 않는 테스트이다. 

* 단일 동작 단위를 검증
* 빠르게 수행
* 다른 테스트와 별도로 처리

예를 들어, 다음과 같은 경우가 고전 스타일의 통합 테스트이다. 

* 둘 이상의 동작 단위를 검증하는 테스트
* 다른 팀이 개발한 모듈이 둘 이상 있을 때 어떻게 작동하는지 검증하기 위한 테스트

#### 2.4.1. 통합 테스트의 일부인 E2E(End-To-End) 테스트

통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트이다. 
E2E 테스트는 통합 테스트의 일부다. 
통합 테스트와 다른 점은 일반적으로 더 많은 의존성이 필요하다는 점이다. 

가끔 경계가 흐리지만, 통합 테스트는 프로세스 외부 의존성 한두 개만 가지고 동작한다. 
E2E 테스트는 프로세스 외부 의존성을 전부 또는 대다수 갖고 동작한다. 
모든 외부 어플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다. 

UI 테스트, GUI 테스트, 기능 테스트와 같은 용어도 사용하며, 사실 모두 동의어이다. 

E2E 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다. 
개인 개발자 머신이 아닌 빌드 서버에서만 실행할 수도 있다. 

E2E 테스트라고 하더라도 외부 의존성을 모두 처리하지 못할 수 있기 때문에 여전히 테스트 대역이 필요하다. 
이런 관점에서 보면 통합 테스트와 E2E 테스트의 뚜렷한 경계를 찾기 힘들다. 
