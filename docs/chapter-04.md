
## 4. 좋은 단위 테스트의 4대 요소

* 테스트는 개발 주기에 통합되어야 한다. 
* 실제로 사용하는 테스트에만 가치가 있고, 그렇지 않으면 작성해도 의미가 없다.
* 코드베이스의 가장 중요한 부분만을 대상으로 한다.
* 모든 실행 코드에 똑같이 신경 쓸 필요가 없다.
* 어플리케이션의 핵심(도메인 모델)을 다른 것과 구별하는 것이 중요하다.
* 최소한의 유지비로 최대 가치를 끌어낸다.

가치 있는 테스트를 식별하는 것과 가치 있는 테스트를 작성하는 것은 별개의 기술이다. 
가치 있는 테스트를 작성하려면 가치 있는 테스트 식별이 필요하다. 

### 4.1. 좋은 단위 테스트의 4대 요소 자세히 살펴보기

좋은 단위 테스트에는 네 가지 특성이 있다.

* 회귀 방지
* 리팩토링 내성
* 빠른 피드백
* 유지 보수성

#### 4.1.1. 첫 번째 요소: 회귀 방지

회귀는 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우이다. 
즉, 소프트웨어 버그를 의미한다. 
개발할 기능이 많을수록 새로운 릴리즈에서 기능이 고장 날 가능성이 높다. 
코드는 자산이 아니라 책임이다. 
코드 베이스가 커질수록 잠재적인 버그에 더 많이 노출된다. 

회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려한다.

* 테스트 중에 실행되는 코드의 양
* 코드 복잡도
* 코드의 도메인 유의성

일반적으로 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다. 
코드가 예외를 발생시키지 않고 실행된다는 것을 아는 데 도움은 되지만, 코드가 생성하는 결과가 유효한지도 확인해야 한다. 
단순한 코드를 테스트하는 것은 가치가 없다. 
단순한 코드를 다루는 테스트는 실수할 여지가 많지 않아서 회귀 오류가 발생하지 않는다. 
라이브러리, 프레임워크 같이 직접 작성하지 않은 코드에 대한 테스트도 중요하다. 
최상의 보호를 위해선 테스트가 해당 라이브러리, 프레임워크, 외부 시스템을 테스트 범주에 포함시켜서 소프트웨어가 의존성에 대한 검증이 올바른지 확인해야 한다. 
회귀 방지 지표를 극대화하려면 테스트가 가능한 많은 코드를 실행하는 것이 좋다. 

#### 4.1.2. 두 번째 요소: 리팩토링 내성

테스트를 빨간색으로 바꾸지 않고 기본 어플리케이션 코드를 리팩토링할 수 있는지에 대한 척도이다. 
리팩토링은 식별할 수 있는 동작을 수정하지 않고 기존 코드를 변경하는 것이다. 
의도는 코드의 비기능적 특징을 개선하는 것으로 가동성을 높이고 복잡도를 낮추는 것이다. 

* 거짓 양성(false positive)
    * 리팩토링 후 테스트가 실패하지만, 실제 기능은 정상적인 케이스
    * 거짓 양성은 허위 경보
    * 실제 의도한 대로 동작하지만 테스트는 실패하는 결과
    * 구현을 수정하지만 식별할 수 있는 동작은 유지할 때 발생

리팩토링 내성 지표에서 테스트 점수가 얼마나 잘 나오는지 평가하려면 테스트에서 얼마나 많이 거짓 양성이 발생하는지 살펴봐야 한다. 
거짓 양성은 전체 테스트 스위트에 치명적인 영향을 주기 때문에 적을수록 좋다. 
단위 테스트의 목적은 프로젝트 성장을 지속 가능하게 하는 것이다. 
회귀 없이 주기적으로 리팩토링하고 새로운 기능을 추가할 수 있어야 한다. 

* 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다.
* 조기 경고 덕분에 결함이 있는 코드가 운영 환경에 배포되기 훨씬 전에 문제를 해결할 수 있다.
* 운영 환경이었으면 문제를 처리하는데 훨씬 더 많은 노력이 필요하다.
* 코드 변경이 회귀로 이어지지 않을 것이라 확신하게 한다.
* 확신이 없으면 리팩토링을 하는 데 주저하게 되고 코드 베이스가 나빠질 가능성이 높아진다. 

거짓 양성은 위 이점들을 모두 방해한다.

* 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다. 
* 시간이 흐르면서 실패에 익숙해지고 그만큼 신경을 많이 쓰지 않는다. 
* 타당한 실패도 무시하기 시작하고 기능이 고장나도 운영 환경에 들어가게 된다. 
* 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰도가 서서히 떨어진다.
* 더 이상 믿을 만한 안전망으로 인식하지 않는다.
* 허의 경보로 인식이 나빠진다.
* 신뢰가 부족해지면 리팩토링이 줄어든다.
* 회귀를 피하려고 코드 변경을 최소한으로 한다.

#### 4.1.3. 무엇이 거짓 양성의 원인인가?

테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다. 
테스트와 테스트 대상 시스템의 구현 세부 사항이 많이 결합될수록 허위 경보가 더 많이 생긴다. 
거짓 양성이 생길 가능성을 줄이는 방법은 구현 세부 사항에서 테스트를 분리하는 것 뿐이다. 
테스트를 통해 SUT가 제공하는 최종 결과를 검증해야 한다. 
최종 사용자의 관점에서 SUT를 검증하고 최종 사용자에게 의미 있는 결과만 확인해야 한다. 
다른 모든 것은 무시해야 한다. 

##### MessageRenderer 구조가 올바른지 확인

* 하위 렌터링 클래스가 예상하는 유형이고, 올바른 순서인지 확인한다.
* 처음에는 좋아보이지만, `MessageRender`의 식별할 수 있는 동작을 실제로 확인하지 않는다.
* 하위 렌더링 클래스의 구성을 바꾸더라고 렌더링하는 HTML 내용은 바뀌지 않을 수 있다.
* 최종 결과는 바뀌지 않지만, 테스트를 수행하면 실패한다. 
* 이는 테스트가 SUT가 생성한 결과가 아니라 구현 세부 사항과 결합했기 때문이다. 
* 이 테스트는 특정 구현만 예상해서 알고리즘을 검사하기 때문에 문제가 발생한다.

```java
package org.example.domain;

import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertInstanceOf;

class MessageRendererTests {

    @Test
    void messageRender_uses_correct_stub_renders() {

        MessageRenderer sut = new MessageRenderer();


        List<Renderer> renderers = sut.subRenders;


        assertEquals(renderers.size(), 3);
        assertInstanceOf(renderers.get(0).getClass(), new HeaderRenderer());
        assertInstanceOf(renderers.get(1).getClass(), new BodyRenderer());
        assertInstanceOf(renderers.get(2).getClass(), new FooterRenderer());
    }
}
```

`MessageRender` 클래스의 상당 부분을 리팩터링하면 테스트가 실패한다. 
리팩터링 과정은 어플리케이션의 식별할 수 있는 동작에 영향을 주지 않으면서 구현을 변경하는 것이다. 
변경할 때마다 테스트가 실패하는 이유는 구현 세부 사항에 연관되 있기 때문이다. 

SUT의 구현 세부 사항과 결합된 테스트는 리팩토링 내성이 없다. 
이런 테스트는 앞에서 설명한 모든 단점을 보여준다.

* 회귀 발생 시 조기 경고를 제공하지 않는다. 
* 대부분 잘못된 것이므로 이런 경고는 무시하게 된다.
* 리팩토링에 대한 능력과 의지를 방해한다.

#### 4.1.4. 구현 세부 사항 대신 최종 결과를 목표로 하기

테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것 뿐이다. 
코드의 내부 작업과 테스트 사이를 가능한 머리 떨어뜨리고 최종 결과를 목표로 해야 한다. 

##### MessageRenderer에서 생성하는 결과 검증

* SUT가 생성하는 결과 값을 확인한다.
* HTML 출력을 똑같이 지키는 한 SUT의 변경 사항은 테스트에 영향을 미치지 않는다. 

```java
package org.example.domain;

import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertInstanceOf;

class MessageRendererTests {

    // ...

    @Test
    void rendering_a_message() {

        MessageRenderer sut = new MessageRenderer();
        Message message = new Message("header", "body", "footer");


        String html = sut.render(message);


        assertEquals("<h1>header</h1><body>body</body><footer>footer</footer>", html);
    }
}
```

단위 테스트는 최종 사용자에게 의미 있는 유일한 결과를 검증한다. 
이런 테스트는 항상 적시에 실패하고 고객에게 영향을 줄 수 있는 어플리케이션 동작의 변경을 알려준다. 

메소드가 변경되어 컴파일 오류가 발생하는 것도 거짓 양성으로 간주한다. 
컴파일 오류 같은 거짓 양성은 해결하기 쉽다. 
컴파일러를 따라 오류가 발생하는 메소드를 고치면 된다. 
좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것이다. 

##### 좋은 테스트와 좋지 않은 테스트

<p align="center">
    <kbd>
        <img src="/images/chapter-04-01.jpg">
    </kbd>
</p>

### 4.2. 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

좋은 단위 테스트의 두 요소 사이에는 본질적인 관계가 있다.

* 회귀 방지
* 리팩토링 내성

둘 다 정반대의 관점에서 테스트 스위트의 정확도에 기여한다. 
프로젝트 초반엔 회귀 방지를 훌륭히 갖추는 것이 중요하지만, 리팩토링 내성은 바로 필요하지 않다. 

#### 4.2.1. 테스트 정확도 극대화

##### 코드 정확도와 테스트 결과

* 코드 정확도와 테스트 결과에 대한 네 가지 결과가 있다.
    * 음성(negative)은 테스트가 성공하는 케이스를 의미한다.
    * 양성(positive)은 테스트가 실패하는 케이스를 의미한다.
* 올바른 추론 - 참 음성
    * 구현체에 문제가 없는 상황에는 테스트가 성공한다.
    * 테스트는 의도적으로 동작했다.
* 올바른 추론 - 참 양성
    * 구현체에 문제가 있는 상황에는 테스트가 실패한다. 
    * 테스트는 의도적으로 동작했다.
* 거짓 음성 - 2종 오류
    * 구현체에 문제가 있지만, 테스트는 성공한다.
    * 테스트가 구현체의 문제를 해결하지 못한다.
    * 회귀 방지를 하기 위한 테스트 코드를 작성하면 거짓 음성의 수를 최소화할 수 있다.
* 거짓 양성 - 1종 오류
    * 리팩토링 이 후에 구현체에 문제가 없지만, 테스트는 실패한다.
    * 이는 허위 경보이므로 개발자로 하여금 시스템의 신뢰도를 낮춘다.
    * 리팩토링 내성을 강화하기 위한 테스트 코드를 작성하면 거짓 양성의 수를 최소화할 수 있다.

<p align="center">
    <kbd>
        <img src="/images/chapter-04-02.jpg">
    </kbd>
</p>

##### 테스트 정확도

테스트는 구현체 코드에 버그가 있는지 없는지를 잘 표현해야 한다. 
거짓 음성과 거짓 양성은 테스트가 보내는 허위 경보이다. 
테스트의 정확도는 허위 경보 대비 실제 구현체 문제가 얼마나 있는지로 판단한다. 

> 테스트 정확도 = 신호(구현체 발견된 버그 수) / 소음(허위 경보 발생 수)

테스트 정확도를 늘리는 방법은 다음과 같다.

* 신호를 늘린다.
    * 버그를 잘 발견할 수 있는 테스트로 개선한다.
    * 회귀 방지를 위한 테스트 코드를 작성한다.
* 소음을 줄인다.
    * 허위 경보를 발생시키지 않도록 테스트를 개선한다.
    * 리팩토링 내성이 강한 구현체 코드를 위한 테스트 코드를 작성한다.

허위 경보가 울리지 않더라도 버그를 찾을 수 없는 테스트는 소용이 없다. 
테스트 코드가 버그를 많이 찾아내더라도 테스트의 소음이 많다면 정확도는 0에 가까워진다. 
혀위 경보는 테스트 코드의 신뢰도를 무너뜨리기 때문에 테스트 코드에 의해 발견되는 버그를 진짜라고 믿을 수 없다. 

#### 4.2.2. 거짓 양성과 거짓 음성의 중요성: 역학 관계

단기적으론 거짓 양성은 거짓 음성보단 영향도가 덜하다. 
프로젝트 초반에 잘못된 경고를 받는 것은 경고를 전혀 받지 않아서 버그가 운영 환경에 들어갈 위험을 감수하는 것보다 낫다. 
하지만, 프로젝트가 진행됨에 따라 거짓 양성은 테스트 스위트에 점점 더 큰 영향을 미친다. 

초기에 거짓 양성이 중요하지 않은 이유는 다음과 같다.

* 프로젝트 초기에는 코드 정리를 많이 할 필요가 없다. 
    * 새로 작성된 코드는 완벽하고 깨끗하다.
    * 개발자의 기억 속에 아직 생생하므로 테스트에서 잘못된 경고가 발생하더라도 쉽게 리팩토링 가능하다.
* 프로젝트 중기에 접어들수록 코드 베이스는 나빠진다.
    * 점점 복잡해지고 체계적이지 않게 된다.
    * 이런 경향을 줄이기 위한 리팩토링이 필요하다.
    * 새로운 기능에 대한 비용이 점점 커진다.
    * 리팩토링이 필요해짐에 따라 리팩토링 내성도 중요해진다.

거짓 양성이 계속 허위 경보를 보낸다면 프로젝트 후반에 거짓 양성을 신경 쓰는 개발자는 사라진다. 
회귀 방지에 중점을 두는 경향이 있다.

* 리팩토링이 중요해지는 시점 전에 개발이 끝나기 때문이다. 
* 프로젝트에 계속 쌓이는 리팩토링 작업을 방해하는 잘못된 경보보다 눈에 띄지 않는 버그를 잡기 위해 최적화한다. 

##### 프로젝트 기간에 따라 거짓 양성, 거짓 음성이 테스트 스위트에 주는 영향도

<p align="center">
    <kbd>
        <img src="/images/chapter-04-03.jpg">
    </kbd>
</p>

### 4.3. 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

